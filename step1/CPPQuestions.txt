1. Explain the different types of containers available in the standard library, what are their differences? Explain use cases for each.
    a. "Sequential containers" are used for data structures that store objects of the same type in a linear manner.
       They are usually implemented as arrays or linked-lists. Used if preserving the order of insertion is a necessity.  
    b. "Sequential container adapters" are a special type of container class that are wrappers around other sequential container types (such as a vector, deque, or  
        list). These container adapters encapsulate the underlying container type and limit the user interfaces accordingly. Used if controlling the order of 
	extraction is desired, ie., LIFO, FIFO, by priority. 
    b. "Associative containers" provide sorted data structures that provide a fast lookup (O(log n) time) using keys. The STL Associative Container types can be 
        divided in two ways: containers which require unique keys, and those which allow multiple entries using the same key. They are usually implemented as binary 
	trees. Used when the order of insertion doesn't matter but sorted entries are desired. 
    c. "Unordered associative containers" provide unsorted data structures that can be accessed using a hash. Access times are O(n) in the worst-case, but much 
        faster than linear time for most operations, with average times of O(1). They are usually implemented as hash tables. Used when sorted entries are not needed 
	and very fast average operation times are required.
2. What are some sorting algorithms, list at least 3? What are their differences and give use cases for each.
   a. "Bubble Sort" is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not 
       suitable for large data sets as its average and worst-case time complexity is quite high. Used for its capability to detect a tiny sorting discrepancy (like a 
       swap of just two elements) in almost-sorted arrays. 
   b. "Merge Sort" is a divide and conquer sorting algorithm. In this algorithm, the array/list is initially divided into two equal halves and then they are combined 
       in a sorted manner. It as a recursive algorithm that continuously splits the array/list in half until it cannot be further divided. 
       Merge Sort is a stable sort which means that elements of equal value in an array/list maintain their original order respectively in the sorted array/list. 
       It requires O(N) extra storage to sort arrays, with N denoting the array size which may be quite expensive. Allocating and de-allocating the extra 
       space used for merge sort with arrays increases the running time of the algorithm. It is used for sorting linked lists as additional 
       space is not required to sort them as you would need to sort arrays, and insertion takes O(1) time.
   c. "Quick Sort" is also a divide and conquer sorting algorithm. It picks an element as a pivot and partitions the given array around the picked pivot. There are 
       several pivot strategies, such as last element, first, random, etc. It is a recursive algorithm that continuously splits the array/list until it cannot be 
       further divided. Quick Sort is an unstable sort which means that elements of equal value in an array/list do not maintain their original order respectively in 
       the sorted array/list. Quick Sort in its general form is an in-place sort and it does not require any extra storage, therefore no extra allocation and 
       deallocation of memory is needed. Due to these factors, Quick Sort is a good choice to sort arrays.
3. What is the purpose of virtual destructors? What types of issues can arise if not used correctly. 
   a.  Making both base and derived classes destructors virtual guarantees that the object of the derived class is destructed properly, i.e., both base class and 
       derived class destructors are called. The order of invocation of such destructors is derived before the base. So one must be careful to not "delete" allocated 
       memory in the base class from the derived class destructor. Also, it must be ascertained that both the base and derived class destructors are virtual, or the 
       destruction of the derived object will have undefined behavior.
4. Explain the keyword: static. What does it mean in each context?
   a. "Global Variables" - the specifier 'static' before the type of the global variable makes it only accessible from within the .cpp file it has been defined in 
       (internal linkage and file scope). It's storage persists for the life of the executing program.
   b. "Local Variables" - the specifier 'static' before the type of the local variable makes it only accessible from within the scope it has been defined in 
       (internal linkage), and its state persists across invocations of said block of code. It's storage persists for the life of the executing program.
   b. "Functions" - the specifier 'static' before the function declaration limits its linkage to internal. It can only be used within the file it was defined in.
   c. "Member Variables of Classes" - the specifier 'static' before the type of the variable within the class makes it accessible outside of an instance of the 
       class (class variable). It is accessible by prepending the class name as a scope identifier along with the scope operator (aClass::staticVar). It's also 
       accessible through an instance of the class, but it's not considered a best practice. It's storage persists for the life of the executing program.
   d. "Functions of Classes" - 
   
5. When are static member variables initialized? 
6. What is the difference between R-Values and L-Values?
7. Is this code safe? If so why? If not why?
	std::string foo()
	{
		std::string something = "avalue";

		return something;
	}
	
	Bonus: What would most compilers do with this code?
8. Why would you use new rather than malloc when allocating an object? Likewise, what's the difference between free and delete?
9. Explain the purpose of std::move, and std::forward. 
10. How do you share resources safely between threads? How would you share an integer value vs user defined type? 
11. What are the some of the principles of object-oriented programming?
12. Explain inheritance vs composition vs aggregation?
13. Should you always initialize variables? 
14. What concept(s) in C++ would you use to manage resources automatically?
	a. How important are these concepts? 	
	b. What tools are you familiar with for tracking resource allocations? 
15. What security concerns have you come across in the past and how have you addressed them?
16. Name some tools and/or techniques that you personally find to be the most helpful surrounding development.
17. Name some tools and/or techniques that you personally find to be the most helpful surrounding code maintenance.   
18. Scenario: You are dealing with legacy code containing no test suites nor documented requirements, and are required to make a change. Describe your expected process for how you may approach the solution. 
	a. Consider both a long term and short-term solutions. 
19. What concerns do you had supporting legacy operating systems? (If any)
20. Tell us about a project you worked on that you found to be interesting or unusual.
