// Daniel Vasconcelos Gomes
// code interview Ninja8
// June 2022
// daniel.vasconcelosgomes@gmail.com


NOTES: 
(1) Some items I admit that I had to research like C++11 threads 
(2) I always cite the website I looked over the internet or the book I used as a reference to answer.
(3) I studied electrical engineering so I never had formal training in data structures so basically I have used C++ STL
for everything. As I indicate below, my answers to sort algorithms were rather rubish because I never had to implement a sort algorithm to use professionally
(4) If anything here looks too brief or not too well explained it was not my intention. Under my mental limitations I tried my best
(5) Thank you for not making me do online tests where you hardly have time to properly do anything and you are asked to go through details of printf formats
(6) I am 49. I still need to learn a lot.
(7) If you see a TODO and something not answered please I apologize I either didnt have time to answer or could not.
(8) I use notepad++ and gcc ( TDM-GCC-64) configured as this web site shows http://www.edparrish.net/common/npp4c.html


References used:

https://www.geeksforgeeks.org
https://isocpp.org/faq
https://cplusplus.com/reference
Sams Teach your self C++ In One hour day Shidarta Rhao 8th Edition
C++ Standard Library Quick Reference P.V Weert/M. Gregoire
Programming principles and pratices B. Stroustrup ( aka the MAN )

Should you require to review more code written by me:

https://github.com/zlogdanbr/mypython  		contains my python code
https://github.com/zlogdanbr/mycpp     		contains a large template header file with my useful classes and functions in C++
https://github.com/zlogdanbr/corona_stat	contains python code wrote to display corona virus statistics
https://github.com/zlogdanbr/framework		contains a C/C++ framework I wrote in 2014 for a small project
https://github.com/zlogdanbr/images		contains code I am organizing into classes to use opencv


1. Explain the different types of containers available in the standard library, what are their differences? Explain use cases for each.

std::string
-----------
https://cplusplus.com/reference/string/string/

std::strings are a very efficient and dynamically allocated and improved string type compared to old ANSI C strings. They contain a huge number of member functions that allow you to trim, copy, use operators, iterate a char buffer. 

std::vector
------------
https://cplusplus.com/reference/vector/vector/

Most commonly used STL container ( if you discard the fact std::string is a container for chars :-) )is std::vector, which is a dynamic array . 
It supports the index [] operator but you can push values into it using the push_back method or pop using push_back. It is usually recommended in place of regular C arrays because it can dynamically change its size allocating it internally. If you intend to access elements by index it is highly recommended because the [] operator returns values in constant time 

https://cplusplus.com/reference/vector/vector/operator[]/

Say you need to store a large number of objects, e.g, a large collection of objects, you would basically simply add them to the container. Suppose this made inside a loop that will be executed several times. By using a vector you safe guard your program to hold all the required objects.

std::vector<myObject> Large
while( Condition )
{
    MyObject o = getObjectFromAnyPlace();
    Large.push_back( o );
    // or use C++11 emplace_back if you want to construct it
}

// let's say now you need to iterate over
for( auto& O: Large )
{
}

or use the [] operator to individually access them. If you need to sort it, or find an element, if you behave exactly as a regular array. I made use of vectors at the code 

https://github.com/zlogdanbr/mycpp/blob/master/src/util.h in the class csvprocessing because I can store elements from a csv file inside a vector<vector<double>> so I can use the values as a 2D array. Suffice to say using a vector is largely cleaner than a regular double 2D C array


std::list
------------
https://cplusplus.com/reference/list/list/
It is a double linked list. 

My favorite definition of its advantage is 

"Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions" 
( https://cplusplus.com/reference/list/list/ )

You cannot do this with a vector, so in cases you need to insert or erase elements in constant time, a list is very efficient.

With a vector, you could not do this.

std::list<int> Large;
while( Condition )
{
    MyObject o = getObjectFromAnyPlace();
    Large.push_back( o );
}

for( auto it = Large.begin(); it != Large.end; it++ )
{
    if ( condition )
    	Large.erase(it);
}

You don't have a [] operator but for everything related to data structures and algorithms you can safely use list

List supports push_back, pop_back, erase, insert and sort method, which is not provided by std::vector and you need to use a STL generic algorithm function sort.
I have taught myself data structures so I implemented a very large double linked list so to learn but what is the point when you got a double LL ready for use

https://github.com/zlogdanbr/mycpp/blob/master/src/util.h
		template<typename T >
		class cllist
		{
		public:
			cllist()

std::deque
------------------
https://cplusplus.com/reference/deque/deque/

A double ended queue. But in reality you get the best of both worlds, but not quite. A deque does not store elements in contigous memory locations so my experience says they are not as fast as a vector. However you can push_front elements in them or pop in both ends.

A dynamic array and a container that allows you to iterate as a linked list. Or more properly

"deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are sequence containers with dynamic sizes that can be expanded or contracted on both ends (either its front or its back)." https://cplusplus.com/reference/deque/deque/

I copy here the complexity of the erase and insert methods of a list and a deque

Deque
erase:Linear on the number of elements erased (destructions). Plus, depending on the particular library implemention, up to an additional linear time on the number of elements between position and one of the ends of the deque.
insert:Linear on the number of elements inserted (copy/move construction). Plus, depending on the particular library implemention, up to an additional linear in the number of elements between position and one of the ends of the deque.

List
erase: Linear in the number of elements erased (destructions).
insert: Linear in the number of elements inserted (copy/move construction).

When you need to mix the behavior it may be a good choice specially if you want to access elements using the operator[]


std::queue
---------------
https://cplusplus.com/reference/queue/queue/

A FIFO ( first in first out queue structure )

Suppose you are gathering financial transacions and they are queued because of timeouts. It seems natural that the ones that need to be taken out of the queues are first ones

std::stack
------------
https://cplusplus.com/reference/stack/stack/

A LIFO ( last in first out)

A stack is usefull when the last element should be the first one removed from the structure due to a priority. searching over the internet I found the example of a stack of plates. 

std::priority_queue
---------------------
https://cplusplus.com/reference/queue/priority_queue/

I honestly never used one.

Now associative containers

std::map/std::multimap/std::set/std::multiset
-----------------------------
https://cplusplus.com/reference/map/

When you need to store elements using a key that you need to use later maps are the best options. For example, if you want to store pairs, one being an indexer and the other the actual value, eg

ID  NAME
0   AA
1   BB
2   CC

You can use a map to store them and retrieve values using the indexer
std::map<int,std::string> m;
//supose you want to assign the values to a map using insert
// to later get it, you can use

std::cout << m[0] << std::endl;

This is made in constant time.

A map does not allow that two equal elements are inserted whereas a multimap does. The drawback is that they require you to provide a means ( a functor, a lambda function) to sort your object and every time an object is inserted inside a map it is sorted. Which has the following complexity

"If a single element is inserted, logarithmic in size in general, but amortized constant if a hint is given and the position given is the optimal."
https://cplusplus.com/reference/map/map/insert/

A set is a container that whose indexer is the element itself. Eg

std::set<int> s;

In the same manner, a set requires you to provide a means ( a functor, a lambda function) to sort your object and every time an object is inserted inside a set it is sorted. 

A multiset allows multiple inputs of the same object.

Although, it is fast to get an element from a set, it will require a sorting operation, which has a nlog(n) complexity, so C++11 introduced the:

std::unordered_set/std::unordered_map
-------------------
https://cplusplus.com/reference/unordered_set/unordered_set/
"Unordered sets are containers that store unique elements in no particular order, and which allow for fast retrieval of individual elements based on their value."

I used it to store pointers to objects dynammical allocated by a class and required fast access to the deletion of the element. Elements are not sorted but you can retrieve them faster.

	void remove( _RPTOBJECT& mptr, const std::string& class_name )
	{

// Complexity
// Average case: constant.
// Worst case: linear in container size.

		auto it = _Allocated_objects.find(mptr);
		if ( it != _Allocated_objects.end() )
		{
			if ( *it != nullptr )
			{
				delete *it;
				*it = nullptr ;
				_Allocated_objects.erase( it );	

			}
		}
		else
		{
			//
		}
	};


2. What are some sorting algorithms, list at least 3? What are their differences and give use cases for each.

https://www.geeksforgeeks.org/bubble-sort/
"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst case time complexity is quite high."

Complexity O(n^2)

https://www.geeksforgeeks.org/selection-sort/
"The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array."

Complexity O(n^2)

https://www.geeksforgeeks.org/quick-sort/
"Like Merge Sort, QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways."

Complexity O(nlog(n))

Note: these algorithms are not my strongest point. I never had any formal training in them and so I basically have used the sort algorithm at the C++ STL, which someone told me to internally use qsort for many STL implementations.

3. What is the purpose of virtual destructors? What types of issues can arise if not used correctly. 

Suppose you have polymorphic very simple set of classes.

class A
{
public:
   A(){};
   virtual ~A(){};
};

then you extend it

class B : public A
{
public:
  B(){};
  virtual ~B(){};
}

if you don't declare the destructors virtual and instantiate  an object B , when destructed it may lead to several errors depending on the compiler you used. By using the virtual destructors you garantee that objects of allocated by both classes are deallocated.


I have seen a case where a program extended a factory class, but the base factory class did not deallocated the objects allocated by the extended one. Worst, the extended class did not even have a destructor. Just by adding the virtual desctructor we reduced the leakage of memory. The we implemented a deallaction mechanism to delete the objects the extended class allocated.



4. Explain the keyword: static. What does it mean in each context?

A static variable means the variable will remain in memory until the program is terminated and its contents can be accessed in your application as long as you inform the linker where it is declared.

static int A = 0;
you can refer to it to the linker by adding
extern int A ; in the start of your source. Ugly but effective

A static variable can also be shared by many instances of the same class.

class A{
public:
  A()
  {
  	count_me++;
  }
  
  static int count_me = 0;
}

So if we have 

A aa{};
A ab{};

Every isntance of A is reflected in the static variabe count_me.

A static function allows you to modify static variables

"It is a member function that is used to access only static data members. It cannot access non-static data members not even call non-static member functions. It can be called even if no objects of the class exist. It is also used to maintain a single copy of the class member function across different objects of the class."

So
class A{
public:

  
  static void foo();
  
}


you may call it as A::foo();




5. When are static member variables initialized? 

When the program is loaded in memory, so they are initialized just once.


6. What is the difference between R-Values and L-Values?

From "the source"

https://isocpp.org/wiki/faq/cpp11-language#rval

"The distinction between lvalues (what can be used on the left-hand side of an assignment) and rvalues (what can be used on the right-hand side of an assignment) goes back to Christopher Strachey (the father of C++’s distant ancestor CPL and of denotational semantics)."

So

char* f = nullptr; // f is a lvalue and nullptr is a rvalue
int b = 1;// b is  a lvalue and 1 is a rvalue




7. Is this code safe? If so why? If not why?
	std::string foo()
	{
		std::string something = “avalue”;
		return something;
	}
	
	Bonus: What would most compilers do with this code?
	
	
When I build that function with

"C:\Program Files (x86)\Embarcadero\Dev-Cpp\TDM-GCC-64\bin\g++.exe"  -Wall -Wextra -Wpedantic -std=c++14 -o "cu" "cu.cpp"
Process started (PID=85256) >>>
cu.cpp:157:26: error: stray '\342' in program
  157 |  std::string something = â€œavalueâ€;
  
  cu.cpp:157:26: error: stray '\342' in program
  157 |  std::string something = â€œavalueâ€;
      |                          ^
cu.cpp:157:27: error: stray '\200' in program
  157 |  std::string something = â€œavalueâ€;
      |                           ^
cu.cpp:157:28: error: stray '\234' in program
  157 |  std::string something = â€œavalueâ€;
      |                            ^
cu.cpp:157:35: error: stray '\342' in program
  157 |  std::string something = â€œavalueâ€;
      |                                   ^
cu.cpp:157:36: error: stray '\200' in program
  157 |  std::string something = â€œavalueâ€;
      |                                    ^
cu.cpp:157:37: error: stray '\235' in program
  157 |  std::string something = â€œavalueâ€;
      |                                     ^
cu.cpp: In function 'std::string foo()':
cu.cpp:157:29: error: 'avalue' was not declared in this scope
  157 |  std::string something = â€œavalueâ€;
      |                             ^~~~~~
      
 So if the actual code contains unicode characters, it will not be compiled.
 
On the other hand if we use
 
std::string foo()
{
	std::string something = "avalue";
	return something;
}
		
int main()
{
	cout << foo() << endl;	
}

it seems safe for me because you are assigning a const char array to c++ stl string.

Ok I decided to build it using
 -v -Wall -Wextra -Wpedantic -std=c++14
 
 And still I don't see any warnings.
 
 There might be a security issue if "avalue" is a confidential data that might be hacked by inspecting the final binary.
 
note:


8. Why would you use new rather than malloc when allocating an object? Likewise, what’s the difference between free and delete?

new is the C++ operator for dynamic allocation. Malloc was created to allocate memory in C programs and it requires some obnoxious castings.
free will simply remove the memory allocated by malloc whereas delete will be run when the object is destructed. free will not call the destructor of a class.

9. Explain the purpose of std::move, and std::forward. 

https://isocpp.org/blog/2018/02/quick-q-whats-the-difference-between-stdmove-and-stdforward


std::move
----------------------
The main purpose is to move the memory resource from one object to other without duplicating memory

"std::move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object."

When you write move contructors and move operators =, you tell the compiler to simply move the memory resource. 

"Move constructor moves the resources in the heap, i.e., unlike copy constructors which copy the data of the existing object and assigning it to the new object move constructor just makes the pointer of the declared object to point to the data of temporary object and nulls out the pointer of the temporary objects. Thus, move constructor prevents unnecessarily copying data in the memory. "
https://www.geeksforgeeks.org/move-constructors-in-c-with-examples/

if you take a look at my repository 
https://github.com/zlogdanbr/mycpp/blob/master/src/util.h

I have a template class that implements a matrix class

template<typename T>
		class Dmatrix final {

I overloaded operators + and -

So say you have do use these operators in a simplified manner, eg

Dmatrix<double> d1;// constuction ommited but internally it holds a vector<vector<double> 

Dmatrix<double> d2;

Dmatrix<double> d3;

If you do this

d1 = d2 + d3; 

You are using the operator +. This operator allocates memory from the stack for a new matrix object that will hold the sum . By using the move constructors you simply avoid copying data and thus saves memory usage

std::forward
----------------
TODO

10. How do you share resources safely between threads? How would you share an integer value vs user defined type? 

Usually a semaphore or a mutex should be used to access data resources that are shared between threads so that they safely access each resource.
C++11 has introduced a threading library to language.

In the code below, the global variable is shared between two threads, which can lead to racing problems

// ...
int global = 0;
void inc() 
{
    global = global + 1;
}

// ...

std::thread t1{inc};
std::thread t2{inc};

// ...

So if we add a mutex object we solve this problem.

#include <mutex>
std::mutex my_mutex;
// ...
int global = 0;
void inc() 
{
    my_mutex.lock();
    global = global + 1;
    my_mutex.unlock();
}

// ...
std::thread t1{inc};
std::thread t2{inc};

So, with a mutex, the variable can be accessed only by the thread that locked it. I found out that C++17 allows a better mechanism

std::mutex my_mutex;
void inc() 
{
    std::lock_guard g(my_mutex;);
    global = global + 1;
}

So you don't have to unlock it, and the RAII principle will apply when g goes out of scope.




11. What are the some of the principles of object-oriented programming?

Polymorphism, inheritance, encapsulation

inheritance: classes House, Apartment and Trailler extend Home.
Polymorphism: Home is a pure virtual class used below as base pointer for all the objects

#include <iostream>
#include <memory>
 
using namespace std;
 
// Base pure virtual class
class Home
{
public:
    Home(){};
    virtual ~Home(){};
    virtual int Build() = 0;
};

// Objects created by factory
// Object 1
class House: public Home
{
public:
    House():Home(){};
    virtual ~House(){ cout << "Destructor House" << endl;};
    virtual int Build() override
    {
        cout << "Building a house..." << endl ;
        return 0;
    };
};
 
// Object 2
class Apartment: public Home
{
public:
    Apartment():Home(){};
    virtual ~Apartment(){ cout << "Apartment" << endl;};
    virtual int Build() override
    {
        cout << "Building a apartment..." << endl ;
       return 0;
    };
};
 
// Object 3
class Trailler: public Home
{
public:
    Trailler():Home(){};
    virtual ~Trailler(){ cout << "Destructor Trailler" << endl;};
    virtual int Build() override
    {
        cout << "Building a Trailler..." << endl ;
        return 0;
    };
};

the factory class use the polimorphic structure

class MyClassFactory
{
public:
    std::unique_ptr<Home> getObjc( int option ) const;
};
 
// we dont have to declare that the method returns a specific
// object we just tell the compiler this will be decided in runtime
// by the compiler who uses this polymorphic structure
std::unique_ptr<Home> MyClassFactory::getObjc( int option ) const
{             
    std::unique_ptr<Home> uptr;
    switch(option)
    {
        case 1:
            uptr = make_unique<House>();
            break;
        case 2:
            uptr = make_unique<Apartment>();       
            break;
        case 3:
            uptr = make_unique<Trailler>();
            break;
        default:
            return nullptr;
    }
    return uptr;
}

encapsulation

The capacity of a class to hide its internal data to be internally accessed. This is controlled by keywork modifiers
public, protected and private. Usually a class would give access to a member variable through accessors 

set and get which set the variable or get its value.


12. Explain inheritance vs composition vs aggregation?

inheritance
-------------
The capacity to extend a base object. Eg

class CandyFactory
{
public:
   Cake returnACake();
};

class CandyAndSnack: public CandyFactory
{
public:
  HHamburguer getHamburguer();
}

Class CandyAndSnack heirs the ability to produce a cake by heritage and implements an hamburguer.

Compositon
---------------
A class internally uses another class

class orange
{
};

class lime
{
};

class banana
{
};

class FruitSalad
{
public:
	FruitSalad(){};
	orange o;
	lime l;
	banana b;
	void doMix()
	{
		// put all the together
	}
}

Agreggation

A pointer to a class is shared by the class

class A
{
public:
};

class B
{
public:
 A* p;
}

int main()
{
	A* a = new A;
	B b;
	b.p = a;

}

13. Should you always initialize variables? 

ALWAYS.


14. Write a program (or multiple) in a known programming language to do the following:
	a. Query for installed windows patches.		
	Please see src/test_win.py        
	b. Query for installed Linux Packages
	Please see src/test_linux.py    
	c. Query for installed Mac Packages	
        I don't have a mac to test, but src/test_linux.py  can be adapted	
15. Write a program (or multiple) in a known programming language to do the following:
	a. Query for windows system information. 
	Please see src/test_win.py
	b. Query for Linux system information
	Please see src/test_linux.py
	c. Query Mac system information
	I don't have a mac to test, but src/test_linux.py  can be adapted
	
16. What concept(s) in C++ would you use to manage resources automatically?
	a. How important are these concepts? 	
	b. What tools are you familiar with for tracking resource allocations? 
	
a) C++11 introduced smart pointers. They allow that memory is properly deallocated whenever it goes out of scope. They are very very important.
C++03 does not have smart pointers just the deprecated and buggy auto_ptr and even so nobody uses it. Factory classes that allocate raw pointer memory are dangerous, as well as filling STL containers with pointers and leaving them there. I have seen huge banking systems go down because of these two

b) When I lastly programmed in Windows ( some 9 years ago ) I used a collection of small apps that allowed me to see threads, linkage and memory space. Visual Studio has improved somehow in this regard. In the last years I used topas and ps commands plus some custom commands to check memories. I am not sure if this is what you asked for. 

17. What security concerns have you come across in the past and how have you addressed them?

1. Test buffers, objects and containers passed to functions or methods always
eg

int foo( char* b)
{
 if ( b == nulltpr )
 	return -1;
//
}

or

int foo( std::vector<int>& s )
{
	// if it is empty it will later give errors
	if ( s.empty() == true )
		return -1;
}

2. If you are not going to change the object or buffer pass it as const

int foo( const char* b)
{
 if ( b == nulltpr )
 	return -1;
//
}

or

int foo( const std::vector<int>& s )
{
	// if it is empty it will later give errors
	if ( s.empty() == true )
		return -1;
}

3. Always indicate properly limits/sizes for raw allocated pointer buffers

int foo( const char* b, size_t n, int MAX )
{
 if ( b == nulltpr )
 	return -1;
//

// after some code you need to check the size using n and MAX

4. Use std::strings not ANSI C null terminated strings

5. First be clear, then optimize
Obfuscated code leads to general misuage 

6. use exceptions but with care and don't abuse of them

7. Don't hardcode 

8. Always think about those malignous beings called hackers when you write code
if you use memcpy be sure to use it checking boundaries
use strncpy only if there is no other way
check if buffers are not NULL before using them

9. Double check a function after you finish it and think as a maligant being. 

10. Use STL vectors always 

11. Smart pointers

12. Code review

13. Listen to testers, let them go berzerk.


}

18. Name some tools and/or techniques that you personally find to be the most helpful surrounding development.

Notepad++, HxD ( hex reader ), Winmerge, Winscp and putty
vim, vi
A decent *nix shell is mandatory even if you have to have cygwin
python
For windows DEFINITELY Visual Studio and Qt for GUIs

A large monitor
sharing knowledge
A C++17 compiler
coffe.
music.


19. Name some tools and/or techniques that you personally find to be the most helpful surrounding code maintenance.  

To know well what you need to modify or fix
A source management tool like SVN.
winmerge
diff
notepad++
sharing knowledge
commenting code
A C++17 compiler
mutual help
history of failures
proper documentation
proper commenting

20. Scenario: You are dealing with legacy code containing no test suites nor documented requirements, and are required to make a change. Describe your expected process for how you may approach the solution. 
	a. Consider both a long term and short-term solutions. 
	
	First thing is learn how to use it, ask the users of the system to explain it. Take notes.
	Learn what the change is.
	For a short term a debugger is mandatory
	find the specific point where you need to change looking at the code and using the debugger
	write your own notes of the architecture.
	fix problems.	
	It will be very good to document the code, and the whole processes.
	
I actually had to this in 2013. There was an authorization system which consisted of a Windows processes and few ISAPIs had to be ported from Visual C++ 2002 to Visual C++ 2010.

21. What concerns do you had supporting legacy operating systems? (If any)

That I recall I had to write a small c++ app for an old Linux distro centos and it was very difficult to find a WxWidgets library
Compilers. I am concerned that a product is updated to a certain OS and the product uses an old compiler.

22. Tell us about a project you worked on that you found to be interesting or unusual.

In 2013 it was my last day at a company. They had put my inside a HUGE brazilian bank. The bank did not know I would leave. At that day, at 6 pm they call me at a desk and said: "Can you help us? There is a hacker trying to do bruteforce attack and we need you to modify a C program to save connection attempts and repetions.  I went home at 6 am the next day. 


