1. Explain the different types of containers available in the standard library, what are their differences? Explain use cases for each.
    
	Sequence containers (such as lists, vectors, and arrays): Elements in these containers retain their order. These are useful when ordering matters. 
	    Use: If you wanted to advance through the days of a week or month, or if you wanted to list the order the colors appear in a rainbow.

    Associative containers (such as maps and sets): These containers associate a value to a key in the container. They are useful if the container needs to be sorted in some way.
	    Use: If you wanted to store employee names[value] based on their employee id[key] or if you wanted to store the price[value] of each book title[key] in your inventory.

    Unordered Associative containers (such as unordered maps and unordered sets): These are similar to maps and sets in that they associate values to keys but they are based on hash table implementations. This makes searching, adding, and deleting elements very quick and efficient. These are best used when ordering is not a requirement.
	    Use: Perhaps if you just wanted to store 

    There are also container adapters (such as queues and stacks): These are simplified interfaces with underlying sequence containers. Queues use a first in first out policy and stacks use a first in last out policy.
	    Use: They can be useful for implementing things such as order of operations in equations or perhaps an event queue where everything needs to be processed in the order it is received.

2. What are some sorting algorithms, list at least 3? What are their differences and give use cases for each.

    Quick sort: This picks a pivot element and puts smaller elements before it and larger elements after it using a partition process that is called. This process is called again on the left part of the array and also the right part, continually on smaller and smaller chunks until the whole array is sorted.
	    Use: This uses in-place sorting so extra memory is not required. If memory is a concern, this is a good algorithm to use. It does not, however, maintain the original ordering of data.

	Bubble sort: This algorithm passes over the entire array, comparing two elements at a time and ordering them. It takes multiple passes until the entire array is completely sorted.
	    Use: This is best used for small data sets such. It gets more and more costly the more data that it sorts through (many many passes).

	Merge sort: This algorithm continually divides the array in half, calling itself on each half until it is broken up into single elements and then merges the sorted halves. 
	    Use: This algorithm has a consistent performance and it is also efficient. Smaller data sets can be handled faster by a simpler algorithm. This one also maintains the order of data elements so it stable.

3. What is the purpose of virtual destructors? What types of issues can arise if not used correctly. 

    Virtual destructors are used as a part of inheritance to ensure that the correct destructor is called at the appropriate time. By this, I mean that an instance of a derived class can be destroyed appropriately if the destructor is called through a pointer to the base class.
	If this is not done correctly, it could result in the child object's destructor not being called which could cause a memory leak. 

4. Explain the keyword: static. What does it mean in each context?

   Static variables in functions have scope for the entirety of the program. They are allocated only once and retain their value.
   
   Static variables in classes are shared by the objects of the class. Any object of that class can make changes to it and it will be reflected in the other objects of the class. Static class objects also have scope for the entirety of the program.
   
   Static functions in a class do not require an object to be called but only have access to static data members or other static functions of the class.

5. When are static member variables initialized? 
    
	They are initialized before the program starts.

6. What is the difference between R-Values and L-Values?
7. Is this code safe? If so why? If not why?
	std::string foo()
	{
		std::string something = �avalue�;
		return something;
	}
	
	Bonus: What would most compilers do with this code?

	"something" is being set to an undefined value. I would not consider that safe. It could result in undefined behavior. I believe most compilers would catch this as an error.

8. Why would you use new rather than malloc when allocating an object? Likewise, what�s the difference between free and delete?

    New calls the constructor of the object and returns the type of the object. Malloc does not call the constructor and returns a void *. Delete calls the destructor of the object in addition to freeing the memory. Free does not. 

9. Explain the purpose of std::move, and std::forward. 

    std::move is used to provide an rvalue (xvalue, specifically) reference from an lvalue or an rvalue reference. This is so that the reference can be used for move semantics as opposed to copy semantics.

	std::forward is used to return the original value category (rvalue or lvalue reference) of a passed argument. This allows for forwarding an lvalue argument as an lvalue and an rvalue argument as an rvalue (within a function the paramater is named, and is treated as an lvalue normally). This can help automatically separate which constructor is called for an object.

10. How do you share resources safely between threads? How would you share an integer value vs user defined type? 

    Resources can be shared with the use of mutex and lock_guard. An integer or user defined type can be shared using a global variable set with the volatile keyword or also through the use of an interface or shared memory.

11. What are the some of the principles of object-oriented programming?
    
	Abstraction: Hide the details and specifics of implementation. Only expose the high level interactions of objects for interaction.

    Encapsulation: Maintain the privacy of the state of an object to itself within the class. Control the internal state of an object inside of the class by making certain data and functions private and controlling how the data or functions can be accessed and used by public class methods. This means having the object maintain its own state.

	Inheritance: Similar objects with common data or functions can share those from an inherited class, only keeping the unique differences within their own class. This means common logic can be reused.

    Polymorphism: Objects can be grouped into collections of their common base classes while retaining their own child methods. This means using a parent interface which can be reused by the child classes to change the logic if necessary.

12. Explain inheritance vs composition vs aggregation?

    Inheritance occurs when a class inherits (takes on) the variables or functionality of a parent class.

	Composition occurs where a class controls another class within itself. The part class is solely managed by the containing class, meaning its lifespan is controlled by the containing class. It also does not, itself, know about the containing class.

	Aggregation is just like composition, except with some slight differences. The part class is not required to solely belong to the containing class (it could belong to many). The part class also is not dependent on the parent objet to exist (its existence is not managed by the containing class).

13. Should you always initialize variables?

    Absolutely. This is always a good idea. It is more useful and efficent than assigning data to it later. Also, it is possible that someone forgets to initialize a variable before using it. That could cause undefined behavior which could be problematic to troubleshoot later.

14. Write a program (or multiple) in a known programming language to do the following:
	a. Query for installed windows patches. 
	b. Query for installed Linux Packages
	c. Query for installed Mac Packages

#include <iostream>

int main()
{
#ifdef __linux__
    system("rpm -qa");
#endif

#ifdef _WIN32
    system("wmic qfe list");
#endif

#ifdef __APPLE__
    system("softwareupdate --history");
#endif
}

15. Write a program (or multiple) in a known programming language to do the following:
	a. Query for windows system information. 
	b. Query for Linux system information
	c. Query Mac system information

#include <iostream>

int main()
{
#ifdef __linux__
    system("uname -a");
#endif

#ifdef _WIN32
    system("systeminfo");
#endif

#ifdef __APPLE__
    system("system_profiler");
#endif
}

16. What concept(s) in C++ would you use to manage resources automatically?
	a. How important are these concepts? 	
	b. What tools are you familiar with for tracking resource allocations? 

	Abstraction and encapsulation become especially important for this. The more specifics about the different resources that can be hidden by higher level functionality, the better. Also depending on what the intent is, it would also be good to make them thread safe if multithreading is a future interest.

	ClearCase is the only resource tracking tool I am familiar with at the moment. I have used it to track activity lifecycles and assignments.

17. What security concerns have you come across in the past and how have you addressed them?

    Much of my experience here comes down to access. I have not come across any concerns in person. Much of the work I have done has been in an isolated network with strict access requirements. There was much concern about the possibility of unauthorized individuals somehow getting physical or visual access to data, and measures were taken to prevent that. Separate keycard and keycode access to different work areas, strict escort of visitors, and separate isolated network environments.

18. Name some tools and/or techniques that you personally find to be the most helpful surrounding development.

    I have really enjoyed using the visual studio and VSCode IDE for development. The version control and tracking systems I have used to this point, I have not cared for. I have been excited to learn and to use GIT. In the linux environment, I have found GDB to be very useful for digging into and troubleshooting any issues.

19. Name some tools and/or techniques that you personally find to be the most helpful surrounding code maintenance.   

    Inserting comments into the code to explain processes is extremely helpful. The use of recognizeable and meaningful variables and constants are also helpful. Without any context, hardcoded numbers are tedious to manage if things ever change, so I find it helpful to use common defined enumerations or constants instead. Automated unit testing is also a huge boon to maintaining code.

20. Scenario: You are dealing with legacy code containing no test suites nor documented requirements, and are required to make a change. Describe your expected process for how you may approach the solution. 
	a. Consider both a long term and short-term solutions. 

    I would first try to determine the original purpose of the code, making notes in a document so someone else does not have to go through as much of a process, hopefully.
	I would consider if there was any steps that could be taken to bring the code to a more modern desing in line with the rest of the system. This could be done incrementally over time, so I would just lay out some steps that could lead that direction. I come up with and document every impact to the current system that the change would effect. I would try to design the change to fit within existing design and patterns that are being used while possibly making it easier to shift the code to a less legacy design. I believe designing a test suite for the change at the least and as much of the legacy code as I could. Then I would code the test suite in conjunction with the change.

21. What concerns do you had supporting legacy operating systems? (If any)

    My biggest concerns would be in regards to security and future support. legacy operating systems tend to fall prey to many security vulnerabilities. If the operating system is no longer supported, than any new security threats will go unchallenged. On the side, there are many software features that may work differently than expected on legacy systems.

22. Tell us about a project your worked on that you found to be interesting or unusual.

    One project that I was working on involved redesigning one portion of the system. The process that ran to simulate a particular entity within our simulation was requested to be changed due to numerous problems. The original design had a process for the entity running on every platform. In the simulation, while platforms were networked together, each platform would publish a separate representation of the entity to the network at the same location. The problem here was that the data between all of them was not synched well. While the simulation was running the multiple overlapping entities at the location would shift around in different ways, making any interactions with the entity very difficult. The customer ended up not using it most of the time. The change was to fix this issue to make the entity more useable as well as to add the capability to have the entity moving and performing other functions. I had to work with our host system engineer to come up with a good design to tackle this issue.

	The platform host and IOS were both heavily tied to the operation of this entity. So I began by trying to separate the functionality from the host as much as possible. I had to insert new capability into the IOS dialogs and control pages as well. In the end, I was able to change the design to a single process that runs on one platform alone and shares the entity data with the other platforms at a consistent rate, so that every platform had the same representation of the entity. I added in functions for the entity to track its own state rather than the host platform performing that.

	I was able to learn about and incorporate the use of shared pointers to manage parts of the logic. Both during, and afterwards, I talked over possible issues and worked out complicated portions with the host engineer.
	
	It was a long complex project and it was very enjoyable. I was able to improve and learn quite a bit while doing it as well.