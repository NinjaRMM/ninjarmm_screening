#ifndef STEP1_TESTS_HPP
#define STEP1_TESTS_HPP
#include <iostream>
#include <sstream>
#include <type_traits>
#include <variant>
#include <utility>
#include "Utils.hpp"

template<typename T>
std::string ToStringImpl(T arg)
{
	std::stringstream ss;
	ss << arg;
	return ss.str();
}

template<typename StrippedArg>
std::vector<std::string> ToStringVec(StrippedArg&& stripped)
{
	std::vector<std::string> outVec;
	outVec.push_back(ToStringImpl(stripped));
	return outVec;
}

template<typename StrippedArg, typename ... ArgTypes>
std::vector<std::string> ToStringVec(StrippedArg&& stripped, ArgTypes&& ... argPack)
{
	size_t packSize = sizeof...(argPack);
	std::vector<std::string> outVec;
	outVec.push_back(ToStringImpl(stripped));
	std::vector<std::string> recurseVec = ToStringVec(argPack ...);
	outVec.insert(outVec.end(), recurseVec.begin(), recurseVec.end());
	return outVec;
}

template<typename ExpectedActual, typename ... ArgTypes>
void PrintError(int&& lineNumber, ExpectedActual&& expected, ExpectedActual&& actual, ArgTypes&& ... args)
{
	std::cout << "Failure at line #:" << lineNumber << std::endl;
	std::cout << "Expected: " << expected << std::endl;
	std::cout << "Got: " << actual << std::endl;
	std::cout << "Inputs: " ;
	std::vector<std::string> inputsVec = ToStringVec(args ...);
	for(auto&& string : inputsVec)
	{
		std::cout << "[" << string << "] ";
	}
	std::cout << std::endl;
}

int main ()
{
	std::cout << "Displaying Basic PrintError functionality (This is not an actual error)" << std::endl;
	PrintError(-1, true, false, 53, 42.5, "word", 'l');

	std::cout << "Testing Utils::IsInBounds" << std::endl;
	// arbitrary bound points
	const uint32_t LOWER_BOUND = 500; 
	const uint32_t UPPER_BOUND = 600;
    std::cout << "Out of lower bounds test" << std::endl;
	bool localTestResult = true;
	bool unitTestResult = true;
	bool globalTestResult = true;
	for (uint32_t testVal = 0; testVal < LOWER_BOUND && localTestResult; testVal += 1)
	{
		bool expected = false;
		bool individualTestResult = Utils::IsInBounds(testVal, LOWER_BOUND, UPPER_BOUND);
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testVal, LOWER_BOUND, UPPER_BOUND);
			localTestResult &= false;
		}
	}
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;
	unitTestResult &= localTestResult;

	std::cout << "In bounds test" << std::endl;
	localTestResult = true;
	for (uint32_t testVal = LOWER_BOUND; testVal <= UPPER_BOUND && localTestResult; testVal += 1)
	{
		bool expected = true;
		bool individualTestResult = Utils::IsInBounds(testVal, LOWER_BOUND, UPPER_BOUND);
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testVal, LOWER_BOUND, UPPER_BOUND);
			localTestResult &= false;
		}
	}
	unitTestResult &= localTestResult;
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;
	
	std::cout << "Out of upper bounds test" << std::endl;
	localTestResult = true;
	bool rolloverProtectionExitCond = false;
	for (uint32_t testVal = UPPER_BOUND + 1; testVal <= UINT32_MAX && localTestResult && !rolloverProtectionExitCond; testVal += 1)
	{
		bool expected = false;
		bool individualTestResult = Utils::IsInBounds(testVal, LOWER_BOUND, UPPER_BOUND);
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testVal, LOWER_BOUND, UPPER_BOUND);
			localTestResult &= false;
		}
		rolloverProtectionExitCond = testVal == UINT32_MAX;
	}
	unitTestResult &= localTestResult;
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;

	std::cout << "Utils::IsInBounds tests " << (unitTestResult ? "passed" : "FAILED") << std::endl;
	globalTestResult &= unitTestResult;

	std::cout << std::endl << "Testing Utils::ContainsTheString" << std::endl;
	unitTestResult = true;
	const std::vector<std::string> stringTestVector = // generated by https://www.lipsum.com/
	{
		"Lorem",		"ipsum",		"dolor",		"sit",		"amet",
		"consectetur",	"adipiscing",	"elit",			"Quisque",	"eleifend",
		"dui",			"quis",			"vestibulum",	"commodo",	"Etiam",
		"tincidunt",	"diam",			"nec",			"lobortis",	"commodo",
		"Nam",			"ultricies",	"urna",			"at",		"bibendum",
		"varius",		"Etiam",		"non",			"nulla",	"at",
		"diam",			"rhoncus",		"lacinia"
	};

	std::cout << "Testing that the string vector contains all it's elements" << std::endl;
	localTestResult = true;
	for (const auto& testString : stringTestVector)
	{
		const bool expected = true;
		const auto count = Utils::ContainsTheString([testString](const std::string& tested) { return tested == testString; }, stringTestVector);
		const bool individualTestResult = count > 0;
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testString);
			localTestResult &= false;
		}
	}
	unitTestResult &= localTestResult;
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;
	
	std::string testString = stringTestVector.at(0);
	std::cout << "Testing that the string \"" << testString << "\" can be found in the string vector" << std::endl;
	{ // test scope
		const bool expected = true;
		const auto count = Utils::ContainsTheString([testString](const std::string& tested) { return tested == testString; }, stringTestVector);
		const bool individualTestResult = (count == 1);
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testString);
			localTestResult &= false;
		}
	}
	unitTestResult &= localTestResult;
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;

	testString = "frog";
	std::cout << "Testing that the string \"" << testString << "\" cannot be found in the string vector" << std::endl;
	{ // test scope
		const bool expected = false;
		const auto count = Utils::ContainsTheString([testString](const std::string& tested) { return tested == testString; }, stringTestVector);
		const bool individualTestResult = (count > 0);
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testString);
			localTestResult &= false;
		}
	}
	unitTestResult &= localTestResult;
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;

	testString = stringTestVector.at(13);
	std::cout << "Testing that the 2 instances of the string \"" << testString << "\" can be found in the string vector" << std::endl;
	{ // test scope
		const bool expected = true;
		const auto count = Utils::ContainsTheString([testString](const std::string& tested) { return tested == testString; }, stringTestVector);
		const bool individualTestResult = (count == 2);
		if (individualTestResult != expected)
		{
			PrintError(__LINE__, expected, individualTestResult, testString);
			localTestResult &= false;
		}
	}
	unitTestResult &= localTestResult;
	std::cout << (localTestResult ? "PASSED" : "FAILED") << std::endl;

	std::cout << "Utils::ContainsTheString tests " << (unitTestResult ? "passed" : "FAILED") << std::endl;
	globalTestResult &= unitTestResult;

	std::cout << std::endl << (globalTestResult ? "All tests passed" : "Test FAILURES") << std::endl;

	return 0;
}

#endif