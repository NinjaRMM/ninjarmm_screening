1. Explain the different types of containers available in the standard library, 
    what are their differences? Explain use cases for each.
    
    *Will try to add recomendations on when to use, anyone can just google the container and get specifics.

    - std::array :
        Fixed size, contiguous memory. 
        Use Whenever you have a fixed size known ahead of time.
        Note: binary search on a fixed array is fast lower_bound and upper_bound are your friends
    - std::vector:
        Dynamically sized, contiguous memory.
        You probably want this, unless you don't, but think very hard before moving on.
    - std::map (rbtree)/std::unordered_map (hashmap):
        Use whenever you need to associate 2 objects or even tag them, if you can always try to use the unordered version
        *If your map is a fixed size Is often more performant to associate your elements in a vector of pairs, do not do it though unless you need optimization though
    - std::deque:
        Optimized for adding elements on either side, pretty good locality
        Think of using these whenever you are constantly adding elements or you need pointer stability
        *if you are using a deque because of pointer stability think of using a vector of unique_ptr's
    -std::stack, std::queue, std::priority queue: 
        Adaptors over other structures mostly over deque.
        You know when you need them 
    - std::set 
        Use when you need a list of unique items, try the unnordered version first 
        *make sure you can't use a sorted vector, ordered insertion can be very fast
    - std::list, std::forward_list:
        Really a hard case to sell, you probably don't want this.
        non-cases for list: pointer stability -> vector \<unique_ptr>, 
            insertion constant time (is overvalued) but a deque will probably do it better.
        If you need a list you probably have a very special case like atomic swap of elements 
         or other use case so you probably should implement a better fit

2. What are some sorting algorithms, list at least 3? What are their differences and 
   give use cases for each.
	1. Radix sort:
        - Description:
			- Stable - Copy / Unstable - In Place 
			- Fastest sorting algorithm if posible to use 
            - O(N + K) in time,
            - O(1) in space, but decently big ~sizeof(int[256])
		- Usages:
			Sorting big data sets of fixed sized elements or lexicographical applications when speed is the only important factor.
		- Cons:
			Posibly one of the most constrained sorts to use, requires lexicographical sense of the object.
			Uses a big amount of memory by default
	2. Quick sort:
		- Description
			- Unstable Sort 
            - In place
            - O(n log(n)) average, bad cases O(n^2)
            - O(log n) space
		- Usages:
            One of the best sorts, decent complexity small space complexity easy to do 
            and fast to execute
			std::sort uses quicksort and fallsback to other sorts (Heapsort) on bad cases (at certain recursion depth)
		- Cons:
            bad cases O(n^2)
	3. Insertion sort
        - Description
			- Stable Sort 
            - In place
            - O(n) best case, O(n^2) average
		- Usages:
            Use on partially sorted elements to provide a fast stable sort algorithm
		- Cons:
            - Try not to use it unless you order you know your data,

3. What is the purpose of virtual destructors? 
   What types of issues can arise if not used correctly. 
    - On a polymorphic context you want to call the most derived destructor, 
        failing to do so might cause an
4. Explain the keyword: static. What does it mean in each context?
   1. File context: Means this element is internal to this translation unit
   2. Class/struct context: Shared by all instances of the class
   3. Function context: Single instance for all calls
5. When are static member variables initialized? 
    - At load-time, if posible, baked in the binary else before main
6. What is the difference between R-Values and L-Values?
    r-values are the temporary values generated by an expression or literal, or by a move expression
    l-values are all the values that are assigned to an expression object or function
7. Is this code safe? If so why? If not why?
	```cpp
	std::string foo()
	{
		std::string something = "avalue";
		return something;
	}
	```
    Yes it is, because it is copying the value

	Bonus: What would most compilers do with this code? 
    NRVO, since c++17 garanteed for most primitive simple objects
8. Why would you use new rather than malloc when allocating an object? 
    Likewise, what's the difference between free and delete?
    - New runs the constructor on the acquired memory and gives you a typesafe pointer to it
    - delete runs the destructor and releases the memory
9. Explain the purpose of std::move, and std::forward. 
    - std::move just indicates to the compiler you are no longer requiring the object so 
        feel free to steal its internal (l-val to r-val cast)
   - forward keeps the cv-qualifiers when forwarding parameters to another function

10. How do you share resources safely between threads? How would you share an integer value vs user defined type? 
    - Atomics or a type of barrier like a mutex or semaphore before accessing the critical data/section
11. What are the some of the principles of object-oriented programming?
    - Composition, Inheritance, Encapsulation, Abstraction, SOLID Principles
12. Explain inheritance vs composition vs aggregation?
    Inheritance:
        Is a way of specializing a class for a particular need, allowing you to get some of the implementation of a base class
    Composition:
        You can incorporate other classes as your members so that you car reuse their functionality, adding them as members.
    Aggregation:
        Can happen when you refer to an object from another, these links are generally 
        loose and might be temporal or change over time

13. Should you always initialize variables? 
    - Yes unless a specific case for performance is made, making sure it is initialized before use
14. What concept(s) in C++ would you use to manage resources automatically?
    RAII (constructors, destructors) and Scopes
	a. How important are these concepts? 	
        Very, RAII warantees you don't forget to cleanup resources an enables new ways of encapsulation
        Scopes are required to understand these lifetimes and when they end.

	b. What tools are you familiar with for tracking resource allocations? 
        * Smart pointers:
            - std::unique_ptr 
            - std::shared_ptr
        * Scope Guards
            - std::unique_lock
            - std::lock_guard
            - std::scoped_lock 
            - std::shared_lock
        * External tools:
            - Valgrind
            - Visual Studio Memory Analisis Tool
15. What security concerns have you come across in the past and how have you 
    addressed them?
    - I worked on automatically fixing heartbleed on Intel's GPU drivers
    - We wrote an automatic tool that would analize the AST and find common patterns to fix
16. Name some tools and/or techniques that you personally find to be the most 
    helpful surrounding development.
    - Fast prototyping: Start as soon as you can, mock everything
    - I find good intellisence is the most helpul: VS +Resharper++, CLion, Visual Assist
        - Examples:
        - Klockwork
        - Clang-tidy
        - Cpp-Check
        - C++ Core-Guidelines Checkers
    - Use Linters, Checkers, Static analisis tools and multiple compilers
    - Agile/Kanban

17. Name some tools and/or techniques that you personally find to be the most helpful surrounding code maintenance.   
    - Make sure you have a good CI system 
    - A Versioning system
    - Make sure that all the code that gets into the codebase is up to standards
        - Code Reviews
        - Automatic Testing (Integration, Unit tests, and fuzzing)
    - Atomic commits, small commits on a repository make simpler to follow changes in the future

18. Scenario: You are dealing with legacy code containing no test suites nor documented requirements, 
    and are required to make a change. Describe your expected process for how you may approach the solution. 
	
    a. Consider both a long term and short-term solutions.
    
    1. Short term:
        - We should isolate the legacy code as much as we can.
        - Try too figure out where we have to make changes and quirurgically make them 
        - Add tests to the touched sections make sure everything is working
    2. Long term:
        1. Add Integration tests. Lets make sure we can keep the code working after our changes
        2. As we start delving into the code make sure to document and add Unit tests to those sections
        3. Ideally we add UT to all the code, rarely is it possible though
        5. Refactor/Separate the application on layers
        4. Try to extract the functionality into a shared library and use it in the code
        6. Add new code on a cleaner/well tested layer

19. What concerns do you had supporting legacy operating systems? (If any)
    - Outdated help or No support
    - New hardware might not allow the system if it gets somehow damaged, imposible to continue working on it
    - Deprecated APIs need to be kept alive, generating almost Zombie code
    - Difficult to reason code filled up with Ifs, can be mannaged though
20. Tell us about a project you worked on that you found to be interesting or unusual. 
    I worked on a very interesting project at the begining of my career, it was a visual aid for bullet forensic experts,
    it allowed us to use cheaper Electronic's Microscope that have a better resolution than the more expensive Comparison microsocopes,
    by making multiple shots and overlaying them we got some 3D info that we could use to enhance features on the bullets

